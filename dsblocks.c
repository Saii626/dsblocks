#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <X11/Xlib.h>

#include "shared.h"

#define STTLENGTH			256
#define LOCKFILE			"/tmp/dsblocks.pid"

#include "blocks.h"
#include "taskqueue.h"

typedef struct {
	Block* blk;
	int sig;
} block_sig_t;

static void buttonhandler(int signal, siginfo_t *si, void *ucontext);
static void setroot();
static void setupsignals();
static void sighandler(int signal, siginfo_t *si, void *ucontext);
static void statusloop();
static void executeblock(void* block);
static void executeblock_sig(void* block);
static void termhandler(int signum);
static int updatestatus();
static void writepid();

Display *dpy;
pid_t pid;

static pthread_mutex_t task_mutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t task_cond = PTHREAD_COND_INITIALIZER;

static int statuscontinue = 1;
static char statusstr[STTLENGTH];
static size_t delimlength;
static sigset_t blocksigmask;

void buttonhandler(int signal, siginfo_t *si, void *ucontext) {
	signal = si->si_value.sival_int >> 8;
	for (Block *current = blocks; current->funcu; current++)
		if (current->signal == signal)
			if (fork() == 0) {
				close(ConnectionNumber(dpy));
				setsid();
				current->funcc(si->si_value.sival_int & 0xff);
				exit(0);
			}
}

void setroot() {
	if (updatestatus()) {
		XStoreName(dpy, DefaultRootWindow(dpy), statusstr);
		XSync(dpy, False);
	}
}

void setupsignals() {
	struct sigaction sa;

	/* to handle HUP, INT and TERM */
	sa.sa_flags = SA_RESTART;
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = termhandler;
	sigaction(SIGHUP, &sa, NULL);
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGTERM, &sa, NULL);

	/* to ignore unused realtime signals */
	// sa.sa_flags = SA_RESTART;
	// sigemptyset(&sa.sa_mask);
	sa.sa_handler = SIG_IGN;
	for (int i = SIGRTMIN + 1; i <= SIGRTMAX; i++)
		sigaction(i, &sa, NULL);

	/* to prevent forked children from becoming zombies */
	sa.sa_flags = SA_NOCLDSTOP | SA_NOCLDWAIT | SA_RESTART;
	// sigemptyset(&sa.sa_mask);
	sa.sa_handler = SIG_DFL;
	sigaction(SIGCHLD, &sa, NULL);

	/* to handle signals generated by dwm on click events */
	sa.sa_flags = SA_RESTART | SA_SIGINFO;
	// sigemptyset(&sa.sa_mask);
	sa.sa_sigaction = buttonhandler;
	sigaction(SIGRTMIN, &sa, NULL);

	/* to handle update signals for individual blocks */
	sa.sa_flags |= SA_NODEFER;
	sa.sa_mask = blocksigmask;
	sa.sa_sigaction = sighandler;
	for (Block *current = blocks; current->funcu; current++)
		if (current->signal > 0)
			sigaction(SIGRTMIN + current->signal, &sa, NULL);
}

void sighandler(int signal, siginfo_t *si, void *ucontext) {
	signal -= SIGRTMIN;
	time_spec_t curr_time;
	for (Block *current = blocks; current->funcu; current++) {
		if (current->signal == signal) {
			clock_gettime(CLOCK_REALTIME, &curr_time);
			block_sig_t* arg = (block_sig_t*)malloc(sizeof(block_sig_t));
			arg->blk = current;
			arg->sig = si->si_value.sival_int;

			Task* newTask = (Task*)malloc(sizeof(Task));
			newTask->task = executeblock_sig;
			newTask->arg = arg;
			newTask->time = curr_time;
			newTask->interval = -1;
			debug(newTask->task_name = "signal_handler";)

			pthread_mutex_lock(&task_mutex);
			add_task(newTask);

#ifdef DEBUG
				char timestr[30]; // to store formatted string
				timespec2str(timestr, 30, &newTask->time);
				printf("Adding task (%d): %s for %s\n", __LINE__, newTask->task_name, timestr);
#endif
			pthread_cond_broadcast(&task_cond);
			pthread_mutex_unlock(&task_mutex);
		}
	}
}

void statusloop() {
	time_spec_t curr_time;
	debug(char timestr[30];) // to store formatted string

	clock_gettime(CLOCK_REALTIME, &curr_time);

#ifdef DEBUG
	timespec2str(timestr, 30, &curr_time);
	printf("Current time (%d): %s\n", __LINE__, timestr);
#endif

	/* first run */
	sigprocmask(SIG_BLOCK, &blocksigmask, NULL);
	debug(printf("Blocked signals (%d)\n", __LINE__);)
	pthread_mutex_lock(&task_mutex);
	for (Block *current = blocks; current->funcu; current++) {
		if (current->interval >= 0)
			current->funcu(current->cmdoutcur, NILL);

		/* Setup tasks */
		if (current->interval > 0) {
			Task* task;
			if ((task = get_new_task())) {
				task->task = executeblock;
				task->arg = current;
				task->interval = current->interval;
				task->time.tv_sec = curr_time.tv_sec + current->interval;
				task->time.tv_nsec = curr_time.tv_nsec;
				debug(task->task_name = current->block_name;)
				add_task(task);
#ifdef DEBUG
				timespec2str(timestr, 30, &task->time);
				printf("Adding task (%d): %s for %s\n", __LINE__, current->block_name, timestr);
#endif
			}
		}
	}
	pthread_mutex_unlock(&task_mutex);
	setroot();
	sigprocmask(SIG_UNBLOCK, &blocksigmask, NULL);
	debug(printf("Unblocked signals (%d)\n", __LINE__);)

	time_spec_t sleep_duration;
	Task* to_run;

	debug(printf("Running main loop (%d)\n", __LINE__);)
	/* main loop */
	while (statuscontinue) {
		clock_gettime(CLOCK_REALTIME, &curr_time);
#ifdef DEBUG
		timespec2str(timestr, 30, &curr_time);
		debug(printf("Current time (%d): %s\n", __LINE__, timestr);)
#endif

		pthread_mutex_lock(&task_mutex);
		to_run = peek_task();

		/* Wait till the time to run the task */
		while(timespec_diff(&to_run->time, &curr_time, &sleep_duration) && statuscontinue) {

#ifdef DEBUG
			timespec2str(timestr, 30, &to_run->time);
			printf("Task \"%s\" is scheduled to run at %s. Sleeping for %ld.%.3ld sec (%d)\n", 
						to_run->task_name, timestr, sleep_duration.tv_sec, sleep_duration.tv_nsec,  __LINE__);
#endif
			pthread_cond_timedwait(&task_cond, &task_mutex, &to_run->time);
			to_run = peek_task();
			clock_gettime(CLOCK_REALTIME, &curr_time);

#ifdef DEBUG
			timespec2str(timestr, 30, &curr_time);
			debug(printf("Sleep complete (%d): %s\n", __LINE__, timestr);)
#endif
		}

		if (!statuscontinue) exit(0);

		to_run = pop_task();
		pthread_mutex_unlock(&task_mutex);

		debug(printf("Blocked signals (%d)\n", __LINE__);)
		sigprocmask(SIG_BLOCK, &blocksigmask, NULL);

		debug(printf("Executing task (%d): %s\n", __LINE__, to_run->task_name);)
		to_run->task(to_run->arg);
		setroot();

		sigprocmask(SIG_UNBLOCK, &blocksigmask, NULL);
		debug(printf("Unblocked signals (%d)\n", __LINE__);)

		if (to_run->interval > 0) {
			// Update task's time
			clock_gettime(CLOCK_REALTIME, &curr_time);
			to_run->time.tv_sec = curr_time.tv_sec + to_run->interval;
			to_run->time.tv_nsec = curr_time.tv_nsec;

			// Re add the task to queue
			pthread_mutex_lock(&task_mutex);
			add_task(to_run);

#ifdef DEBUG
			timespec2str(timestr, 30, &to_run->time);
			printf("Adding task (%d): %s for %s\n", __LINE__, to_run->task_name, timestr);
#endif

			pthread_cond_broadcast(&task_cond);
			pthread_mutex_unlock(&task_mutex);
		} else {
			// The task was a signal handler task. free relevant structures
			free(to_run->arg);
			free(to_run);
		}
	}
}

void executeblock(void* block) {
	Block* blk = (Block*) block;
	blk->funcu(blk->cmdoutcur, NILL);
}

void executeblock_sig(void* blocksig) {
	block_sig_t* block_sig = (block_sig_t*) block_sig;
	block_sig->blk->funcu(block_sig->blk->cmdoutcur, block_sig->sig);
}

void termhandler(int signum) {
	statuscontinue = 0;
}

/* returns whether block outputs have changed and updates statusstr if they have */
int updatestatus() {
	char *s = statusstr;
	char *c, *p; /* for cmdoutcur and cmdoutprv */
	const char *d; /* for delimiter */
	Block *current = blocks;

	/* checking half of the function */
	/* skip empty blocks */
	for (;;) {
		if (!current->funcu)
			return 0;
		/* skip delimiter for the first non-empty block */
		if (*current->cmdoutcur != '\0' && *current->cmdoutcur != '\n')
			goto skipdelimc;
		if (*current->cmdoutcur != *current->cmdoutprv) {
			*current->cmdoutprv = *current->cmdoutcur;
			current++;
			goto update0;
		}
		current++;
	}

	/* main loop */
	for (; current->funcu; current++) {
		/* handles delimiter */
		if (*current->cmdoutcur != '\0' && *current->cmdoutcur != '\n')
			s += delimlength;
		else {
			if (*current->cmdoutcur != *current->cmdoutprv) {
				*current->cmdoutprv = *current->cmdoutcur;
				current++;
				goto update1;
			}
			continue;
		}

skipdelimc:
		c = current->cmdoutcur; p = current->cmdoutprv;
		if (*c != *p)
			goto update2;
		else {
			c++; p++;
		}
		for (; *c != '\0' && *c != '\n'; c++, p++)
			if (*c != *p) {
				s += c - current->cmdoutcur;
				goto update2;
			}
		s += c - current->cmdoutcur;
		if (current->funcc && current->signal)
			s++;
	}
	return 0;

update0:
	/* updating half of the function */
	/* skip empty blocks */
	for (;;) {
		if (!current->funcu)
			return 1;
		/* skip delimiter for the first non-empty block */
		if (*current->cmdoutcur != '\0' && *current->cmdoutcur != '\n')
			goto skipdelimu;
		*current->cmdoutprv = *current->cmdoutcur;
		current++;
	}

update1:
	/* main loop */
	for (; current->funcu; current++) {
		/* handles delimiter */
		if (*current->cmdoutcur != '\0' && *current->cmdoutcur != '\n') {
			d = delim;
			while (*d != '\0')
				*(s++) = *(d++);
			*(s++) = '\n'; /* to mark the end of delimiter */
		} else {
			*current->cmdoutprv = *current->cmdoutcur;
			continue;
		}

skipdelimu:
		c = current->cmdoutcur; p = current->cmdoutprv;

update2:
		do {
			*(s++) = *c;
			*p = *c;
			c++; p++;
		} while (*c != '\0' && *c != '\n');
		if (current->funcc && current->signal)
			*(s++) = current->signal;
	}
	*s = '\0';
	return 1;
}

void writepid() {
	int fd;
	struct flock fl;

	fd = open(LOCKFILE, O_RDWR|O_CREAT, 0644);
	if (fd == -1) {
		perror("writepid - fd");
		exit(1);
	}
	fl.l_type = F_WRLCK;
	fl.l_start = 0;
	fl.l_whence = SEEK_SET;
	fl.l_len = 0;
	if (fcntl(fd, F_SETLK, &fl) == -1) {
		if (errno == EACCES || errno == EAGAIN) {
			fputs("Error: another instance of dsblocks is already running.\n", stderr);
			exit(2);
		}
		perror("writepid - fcntl");
		exit(1);
	}
	if (ftruncate(fd, 0) == -1) {
		perror("writepid - ftruncate");
		exit(1);
	}
	if (dprintf(fd, "%ld", (long)pid) < 0) {
		perror("writepid - dprintf");
		exit(1);
	}
}

void* acpi_handler(void* ptr) {
	Block* volBlock = (Block*) ptr;
	volBlock->funcu(volBlock->cmdoutcur, NILL);
	return NULL;
}

//void
//spawnacpihandler() {
//	pthread_t acpilistener;
//
//	Block* volBlock;
//	for (Block *current = blocks; current->funcu; current++) {
//		if (current->signal == VOLUME_SIGNAL) {
//			volBlock = current;
//			break;
//		}
//	}
//
//	pthread_create(&acpilistener, NULL, acpi_handler, volBlock);
//}


int main(int argc, char *argv[]) {
	pid = getpid();
	writepid();
	if (argc > 2)
		if (strcmp(argv[1], "-d") == 0)
			delim = argv[2];
	delimlength = strlen(delim) + 1;
	if (!(dpy = XOpenDisplay(NULL))) {
		fputs("Error: could not open display.\n", stderr);
		return 1;
	}

	debug(printf("Setting up signals (%d)\n", __LINE__);)
	sigemptyset(&blocksigmask);
	sigaddset(&blocksigmask, SIGHUP);
	sigaddset(&blocksigmask, SIGINT);
	sigaddset(&blocksigmask, SIGTERM);
	for (Block *current = blocks; current->funcu; current++)
		if (current->signal > 0)
			sigaddset(&blocksigmask, SIGRTMIN + current->signal);
	setupsignals();

	debug(printf("Running status loop (%d)\n", __LINE__);)
	statusloop();
	unlink(LOCKFILE);
	XStoreName(dpy, DefaultRootWindow(dpy), "");
	XCloseDisplay(dpy);
	return 0;
}
